1
00:00:00,000 --> 00:00:07,182
[MUSIC]

2
00:00:07,182 --> 00:00:08,770
Welcome to this lecture.

3
00:00:08,770 --> 00:00:10,970
Today we will learn the Alpha algorithm.

4
00:00:10,970 --> 00:00:15,270
This is the first concrete discovery
technique presented in this

5
00:00:15,270 --> 00:00:16,769
course on process mining.

6
00:00:18,180 --> 00:00:22,390
Here you see a picture that we
have shown several times before.

7
00:00:22,390 --> 00:00:25,910
It is showing play-in,
play-out, and replay.

8
00:00:25,910 --> 00:00:28,625
So process discovery
corresponds to play-in.

9
00:00:30,050 --> 00:00:34,520
If you take a look at this picture
that by now should look very familiar.

10
00:00:34,520 --> 00:00:38,920
We are now focusing on the green
arrow indicated discovery.

11
00:00:38,920 --> 00:00:44,000
So from an event log, we will
automatically learn a process model.

12
00:00:44,000 --> 00:00:46,670
In our case, for
the Alpha algorithm, a Petri net.

13
00:00:48,630 --> 00:00:52,150
So the Alpha algorithm was the first or

14
00:00:52,150 --> 00:00:57,310
one of the first algorithms being
able to discover concurrency.

15
00:00:57,310 --> 00:01:02,050
And so from event logs we want to learn
models that can have loops, that

16
00:01:02,050 --> 00:01:06,490
can have parallel parts, that can have
choices, and the Alpha algorithm was

17
00:01:06,490 --> 00:01:11,400
the first algorithm being able to do that
while guaranteeing certain properties.

18
00:01:12,950 --> 00:01:17,050
So what kind of input does
the Alpha algorithm use?

19
00:01:17,050 --> 00:01:22,710
We have seen event logs like this, and
when we apply the Alpha algorithm and

20
00:01:22,710 --> 00:01:24,970
we just focus on control flow.

21
00:01:24,970 --> 00:01:29,620
So we ignore the resources and
other data elements.

22
00:01:29,620 --> 00:01:35,550
We ignore the actual timestamps
at which the events take place.

23
00:01:35,550 --> 00:01:38,580
We only care about their ordering.

24
00:01:38,580 --> 00:01:44,170
Also, we don't use the case ID or
properties of the case.

25
00:01:44,170 --> 00:01:52,340
We only look at the order of
activities within a particular case.

26
00:01:52,340 --> 00:01:58,450
So we can convert such an event
log to a multiset of traces.

27
00:01:58,450 --> 00:02:02,550
And each trace is a sequence of
activity names, as you can see here.

28
00:02:03,810 --> 00:02:06,830
So this is kind of based
on a real life log.

29
00:02:06,830 --> 00:02:10,170
We can also take a look at
a more abstract example.

30
00:02:10,170 --> 00:02:16,800
Here we see a log L1 which
contains six traces.

31
00:02:16,800 --> 00:02:20,250
You can think of them as six different cases.

32
00:02:20,250 --> 00:02:24,890
And they are modeled as
a sequence of activity names.

33
00:02:24,890 --> 00:02:29,580
So, the sequence a, b, c,
d was executed three times.

34
00:02:29,580 --> 00:02:31,910
There are three traces of that type.

35
00:02:33,003 --> 00:02:35,790
So an event log is a multiset of traces,

36
00:02:35,790 --> 00:02:40,440
because the same trace can appear multiple
times, and a trace is a sequence of

37
00:02:40,440 --> 00:02:44,700
activity names where we abstract
from all the other attributes.

38
00:02:44,700 --> 00:02:48,100
We will use these other
attributes in later lectures.

39
00:02:50,000 --> 00:02:52,000
So what is the goal of
the Alpha algorithm?

40
00:02:52,000 --> 00:02:58,460
If we feed it a log like L1 we want to
automatically learn a process model

41
00:02:58,460 --> 00:03:04,050
as is shown here that allows for
the behavior that we have seen in the log.

42
00:03:04,050 --> 00:03:07,280
So that's like a minimal
desire that we have.

43
00:03:08,850 --> 00:03:14,440
Here you see another example
an event log which is a bit bigger.

44
00:03:14,440 --> 00:03:18,230
If we feed this event log
to the Alpha algorithm,

45
00:03:18,230 --> 00:03:23,540
it will automatically learn this process
model, which indeed captures all

46
00:03:23,540 --> 00:03:27,380
the behaviors that we have seen,
but also more behaviors.

47
00:03:27,380 --> 00:03:30,600
because there is a loop, so
in principle this model allows for

48
00:03:30,600 --> 00:03:36,450
infinitely many traces, but it is
based on a finite number of examples.

49
00:03:40,250 --> 00:03:43,260
In this course we will not
care too much about notations,

50
00:03:43,260 --> 00:03:46,390
we have been talking about
notations in earlier lectures.

51
00:03:46,390 --> 00:03:48,700
You can represent
a behavior as a Petri net.

52
00:03:48,700 --> 00:03:51,040
You can represent it as a BPMN model.

53
00:03:51,040 --> 00:03:55,870
You can represent it as an EPC,
as a UML activity diagram.

54
00:03:55,870 --> 00:03:57,100
We do not care.

55
00:03:57,100 --> 00:03:59,060
We just want to capture the behavior.

56
00:04:00,110 --> 00:04:04,070
So here you see two process models
that express exactly the same in

57
00:04:04,070 --> 00:04:06,020
two different languages.

58
00:04:06,020 --> 00:04:10,210
Here you see another
pair of process models.

59
00:04:10,210 --> 00:04:15,030
One in terms of Petri nets, the other
in terms of BPMN, that express exactly

60
00:04:15,030 --> 00:04:20,070
the same behavior and can replay
the behavior that we have seen in log L2.

61
00:04:22,900 --> 00:04:27,660
Process discovery is
incredibly challenging.

62
00:04:27,660 --> 00:04:31,760
One has many competing requirements, and

63
00:04:31,760 --> 00:04:37,400
the four main quality criteria for a
discovered model are shown in this slide.

64
00:04:37,400 --> 00:04:42,610
Just like you need several
forces to keep a plane into the air.

65
00:04:42,610 --> 00:04:46,450
We need to work with several forces
when we discover a process model.

66
00:04:47,550 --> 00:04:48,240
In this lecture,

67
00:04:48,240 --> 00:04:53,480
we will mostly focus on fitness, the
ability to replay the observed behavior.

68
00:04:53,480 --> 00:04:57,280
But you'll learn in later lectures,
we will see that it is not that simple.

69
00:04:59,710 --> 00:05:01,040
Okay, let's start.

70
00:05:01,040 --> 00:05:03,280
Let's take a look at the Alpha algorithm.

71
00:05:03,280 --> 00:05:07,800
The starting point for the Alpha
algorithm are ordering relations.

72
00:05:08,880 --> 00:05:11,390
So, we do not care about frequencies.

73
00:05:11,390 --> 00:05:13,190
We do not care about other attributes.

74
00:05:13,190 --> 00:05:17,800
In this case, we are only interested in
seeing that in the log, we could see that,

75
00:05:17,800 --> 00:05:20,180
that there was a sequence a, b,

76
00:05:20,180 --> 00:05:23,690
c, d and that we could see
that a was followed by b.

77
00:05:23,690 --> 00:05:27,580
And b was followed by c and
c was followed d.

78
00:05:27,580 --> 00:05:32,060
This relationship is
called direct succession.

79
00:05:32,060 --> 00:05:37,390
There was at least one case where
x was directly followed by y.

80
00:05:37,390 --> 00:05:41,960
So if we look at this event log
we can find these relations.

81
00:05:41,960 --> 00:05:45,000
So, for example,
if we take a look at the top one

82
00:05:45,000 --> 00:05:50,440
it says that there was at least one
case where a was directly followed by b.

83
00:05:50,440 --> 00:05:52,200
That's highlighted in the diagram.

84
00:05:54,550 --> 00:05:56,270
Then there is a second relation.

85
00:05:56,270 --> 00:06:01,260
It's called causality and
it is depicted by an arrow.

86
00:06:01,260 --> 00:06:07,560
This means that x is followed by y,
but y is never followed by x.

87
00:06:07,560 --> 00:06:14,050
So we can again take a look at our very
simple event log, and we will see that

88
00:06:14,050 --> 00:06:21,790
a is sometimes directly followed by b,
but b is never followed by a.

89
00:06:21,790 --> 00:06:28,396
So we derive this a arrow b property,
causality.

90
00:06:28,396 --> 00:06:32,580
If the direct succession
relation holds in both directions,

91
00:06:32,580 --> 00:06:35,210
we say that things are in parallel.

92
00:06:35,210 --> 00:06:39,970
So we say x parallel y if x is

93
00:06:39,970 --> 00:06:44,280
sometimes followed by y and
y is sometimes followed by x.

94
00:06:44,280 --> 00:06:48,760
So again if we look at the model we
can see that, that holds for b and c.

95
00:06:48,760 --> 00:06:53,930
So b is sometimes followed by c and
c is sometimes followed by b.

96
00:06:55,950 --> 00:07:02,800
The last relationship holds if x is
never directly followed by y and

97
00:07:02,800 --> 00:07:08,130
y is never directly followed by x, we then
say that there is a choice relationship.

98
00:07:09,680 --> 00:07:14,240
So for example,
if we take a look at the log, and

99
00:07:14,240 --> 00:07:20,020
we derive the relationships we will
see that b is never followed by e.

100
00:07:20,020 --> 00:07:24,680
And e is never followed by b, so we say
that they are in a choice relationship.

101
00:07:26,550 --> 00:07:31,500
These relations are used to
learn patterns in the process.

102
00:07:31,500 --> 00:07:35,620
So if we see a is sometimes followed by b,
but

103
00:07:35,620 --> 00:07:41,660
b is never followed by a, this is the
Petri net pattern that we expect to see.

104
00:07:41,660 --> 00:07:42,360
A sequence.

105
00:07:44,120 --> 00:07:49,280
If we see that a is sometimes followed
by b, but never the other way around,

106
00:07:49,280 --> 00:07:54,530
a is sometimes followed by c, but
c is never followed by a, and b and

107
00:07:54,530 --> 00:08:00,510
c never follow one another,
we learn this XOR-split pattern.

108
00:08:00,510 --> 00:08:04,520
So apparently after doing a,
there is a choice between b or c.

109
00:08:05,710 --> 00:08:08,620
Note that if we replay
this Petri net we will

110
00:08:08,620 --> 00:08:11,370
get exactly these types of relationships.

111
00:08:12,640 --> 00:08:17,760
The corresponding part to the XOR-split
is the XOR-join that you can see here.

112
00:08:17,760 --> 00:08:22,680
And if you look at the ordering relations
I think it's fairly obvious.

113
00:08:22,680 --> 00:08:26,430
So, b has a causal relationship with d,

114
00:08:26,430 --> 00:08:30,770
c has a causal relationship with d,
but b and c never follow one another.

115
00:08:33,180 --> 00:08:37,420
If we look at concurrency we
see the following behavior.

116
00:08:37,420 --> 00:08:42,880
If we would look at an AND-split where
a is followed by both b and c but

117
00:08:42,880 --> 00:08:44,810
they can be done in any order.

118
00:08:44,810 --> 00:08:46,530
Perhaps at the same time.

119
00:08:46,530 --> 00:08:50,760
Then we will find that a is
sometimes followed by b.

120
00:08:50,760 --> 00:08:53,010
But never the other way around.

121
00:08:53,010 --> 00:08:56,760
A is sometimes followed by c,
but c is never followed by a.

122
00:08:57,860 --> 00:09:00,520
And b is sometimes followed by c.

123
00:09:00,520 --> 00:09:03,260
And c is sometimes followed by b.

124
00:09:04,320 --> 00:09:08,070
So if you would replay the token
game on top of this fragment,

125
00:09:08,070 --> 00:09:10,760
you would indeed see that
these relationships hold.

126
00:09:10,760 --> 00:09:15,060
So this is an indication that
a process has such a pattern.

127
00:09:16,390 --> 00:09:19,360
Again, we can look at
the corresponding join pattern.

128
00:09:19,360 --> 00:09:25,130
So what we now see is that again, b and
c can follow one another in any order,

129
00:09:25,130 --> 00:09:29,200
and we have observed at least
once that b was followed by c.

130
00:09:29,200 --> 00:09:31,530
And at least once that
c was followed by b.

131
00:09:32,710 --> 00:09:35,630
Typically in different traces.

132
00:09:35,630 --> 00:09:39,560
And we sometimes see that b is followed
by d but not the other way around, and

133
00:09:39,560 --> 00:09:42,270
sometimes c is followed by d,
not the other way around.

134
00:09:43,610 --> 00:09:49,200
So based on these patterns we can
automatically construct a Petri net.

135
00:09:50,260 --> 00:09:53,070
And so here, we revisit the example and
you can see that these

136
00:09:53,070 --> 00:09:57,600
patterns are there but actually in this
example, it's already a bit more involved.

137
00:09:57,600 --> 00:10:01,450
And the Alpha algorithm can also
handle many more situations.

138
00:10:03,870 --> 00:10:09,490
So let's take a look at these ordering
relations in a bit more detail.

139
00:10:09,490 --> 00:10:13,710
When we take an event log we can
talk about so-called footprints and

140
00:10:13,710 --> 00:10:16,360
that's the matrix that
you see on this slide.

141
00:10:18,500 --> 00:10:24,450
Every cell in this matrix has
one of these four relationships.

142
00:10:24,450 --> 00:10:27,450
So we either have a causality
in one direction,

143
00:10:27,450 --> 00:10:33,890
a causality in the other direction, the
two activities never follow one another,

144
00:10:33,890 --> 00:10:37,630
or they sometimes follow each
other in one direction and

145
00:10:37,630 --> 00:10:39,170
other times in another direction.

146
00:10:39,170 --> 00:10:42,280
These are the only four
possibilities that we have.

147
00:10:42,280 --> 00:10:46,040
So in this example,
a is sometimes followed by c, but

148
00:10:46,040 --> 00:10:47,290
c is never followed by a.

149
00:10:49,260 --> 00:10:55,510
So if we take a look at the event log and
the corresponding process model,

150
00:10:55,510 --> 00:11:00,290
we will see that both actually
have exactly the same footprint.

151
00:11:00,290 --> 00:11:04,630
So if we would analyze the process
model and look at all the traces and

152
00:11:04,630 --> 00:11:09,550
create this footprint based
on all the possible traces,

153
00:11:09,550 --> 00:11:11,850
this would be the matrix that we see.

154
00:11:11,850 --> 00:11:16,990
So model and event log agree on
the footprint, indicating that

155
00:11:16,990 --> 00:11:20,430
they have from a behavioral point of view,
things in common.

156
00:11:22,300 --> 00:11:24,130
We can take a look at another log.

157
00:11:24,130 --> 00:11:25,540
A more involved example.

158
00:11:25,540 --> 00:11:27,510
And again, we see the same phenomena.

159
00:11:27,510 --> 00:11:33,000
The event log and the process model
have exactly the same footprint.

160
00:11:33,000 --> 00:11:37,290
Suggesting that this model is indeed
the model of the behavior that we have seen.

161
00:11:39,020 --> 00:11:44,730
So, to summarize this part,
when we talk about footprints,

162
00:11:44,730 --> 00:11:49,070
we see certain patterns that
are reflected both in the log and

163
00:11:49,070 --> 00:11:53,480
in the model, and these are the starting
point for the Alpha algorithm.

164
00:11:56,310 --> 00:11:59,480
The Alpha algorithm is
a very basic algorithm.

165
00:11:59,480 --> 00:12:05,010
It contains only eight lines but
they look scary at first sight.

166
00:12:05,010 --> 00:12:09,580
So I will walk through these
eight lines step by step.

167
00:12:10,880 --> 00:12:14,590
And it's surprising that with
such a simple algorithm,

168
00:12:14,590 --> 00:12:19,820
you can actually discover such
a wide range of different processes.

169
00:12:19,820 --> 00:12:25,340
Processes having concurrency, processes
having loops, processes having choices.

170
00:12:25,340 --> 00:12:30,270
All of these things can be discovered
by this very basic algorithm.

171
00:12:30,270 --> 00:12:34,450
But it looks very scary, I have to admit,
so let's walk through it step by step.

172
00:12:35,720 --> 00:12:41,210
So we start with an event log,
which is a multi-set of traces.

173
00:12:41,210 --> 00:12:46,270
And if we construct
a Petri net using the Alpha algorithm,

174
00:12:46,270 --> 00:12:49,490
the first step that we take
is that we scan the event log

175
00:12:49,490 --> 00:12:54,420
to see what are the activities or what
are the transitions that are appearing.

176
00:12:54,420 --> 00:12:59,220
So we just look at the symbols
that occur in the event log.

177
00:13:00,890 --> 00:13:04,950
So these will be the activities
in the process model,

178
00:13:04,950 --> 00:13:07,250
each corresponding to a transition.

179
00:13:07,250 --> 00:13:08,780
That's why we use the symbol T here.

180
00:13:10,580 --> 00:13:14,620
Then we have the initial transitions, TI.

181
00:13:14,620 --> 00:13:19,730
These are the transitions that
are the first in a trace.

182
00:13:19,730 --> 00:13:22,400
So we can look at all the traces and
look at

183
00:13:22,400 --> 00:13:27,220
what are the different activities that
happen in the first position of the trace.

184
00:13:28,730 --> 00:13:34,510
Similarly we can look at TO,
the set of final activities.

185
00:13:34,510 --> 00:13:39,550
End activities that happen
at the end of a trace.

186
00:13:39,550 --> 00:13:41,420
So we have all activities.

187
00:13:41,420 --> 00:13:43,900
Activities that happen at the beginning,
and

188
00:13:43,900 --> 00:13:46,290
activities that happen at the very end.

189
00:13:48,440 --> 00:13:54,150
After we have done this,
we have the key step to discover places.

190
00:13:54,150 --> 00:13:57,652
If you think about process
discovery in terms of

191
00:13:57,652 --> 00:14:00,760
Petri nets it's all about
discovering places.

192
00:14:00,760 --> 00:14:06,150
And we will discover places by
identifying sets of transitions, A and

193
00:14:06,150 --> 00:14:09,020
B, where A are the input transitions for

194
00:14:09,020 --> 00:14:12,850
the place and B are the output
transitions for the place.

195
00:14:12,850 --> 00:14:15,000
And we do that in a number of steps.

196
00:14:16,670 --> 00:14:22,140
So this is the fourth line of
the description of the Alpha algorithm.

197
00:14:22,140 --> 00:14:24,910
As I said, it,
it looks perhaps a bit scary.

198
00:14:24,910 --> 00:14:30,220
But if you look at the intuitive idea
behind it, it's really simple.

199
00:14:30,220 --> 00:14:38,010
So we are trying to find two
sets of activities, A and B.

200
00:14:38,010 --> 00:14:40,395
And these activities should
have the following property.

201
00:14:41,510 --> 00:14:48,200
If I take two activities in the set A,
they should never follow one another.

202
00:14:49,850 --> 00:14:56,090
If I take two activities in the set B,
they should also never follow one another.

203
00:14:56,090 --> 00:15:00,490
Even if we take the same activity,
it should never follow itself.

204
00:15:00,490 --> 00:15:03,200
And so that's one requirement.

205
00:15:03,200 --> 00:15:05,060
The second requirement.

206
00:15:05,060 --> 00:15:10,380
If we take any activity in the set A and
we take any activity in the set B,

207
00:15:12,140 --> 00:15:17,360
there should always be a direct
succession between these two activities.

208
00:15:17,360 --> 00:15:21,870
So there should be at least one position
in the log where the element of

209
00:15:21,870 --> 00:15:26,830
A is followed by the element of B and
that should hold for all combinations.

210
00:15:26,830 --> 00:15:29,120
So that's what it says
in this fourth line.

211
00:15:31,590 --> 00:15:38,390
So if we take a look at the footprint
matrix we can recognize this structure

212
00:15:38,390 --> 00:15:44,070
because we are looking for a set a and
b where things never follow one another.

213
00:15:44,070 --> 00:15:49,640
And we are looking for these other
connections where any element of a is

214
00:15:49,640 --> 00:15:54,780
directly followed by any element of b,
but never the other way around.

215
00:15:54,780 --> 00:15:57,670
That is what is indicated
here in the matrix.

216
00:15:57,670 --> 00:16:02,510
So that is what we are looking for
but that is not sufficient.

217
00:16:04,140 --> 00:16:09,680
Line five of the algorithm says that
we should only look at the sets A and

218
00:16:09,680 --> 00:16:10,910
B that are maximal.

219
00:16:12,040 --> 00:16:15,130
And it's very easy to see
why that is the case.

220
00:16:15,130 --> 00:16:18,680
Suppose that we have this pair of

221
00:16:19,740 --> 00:16:25,060
set of activities A and set of activities
B, having all these requirements.

222
00:16:25,060 --> 00:16:28,550
Then if we remove a node in A or B.

223
00:16:28,550 --> 00:16:33,190
Or we remove
the corresponding arcs.

224
00:16:33,190 --> 00:16:37,590
What we see then is that
still the properties hold.

225
00:16:37,590 --> 00:16:42,830
So any, in a way any subset
of this AB relationship

226
00:16:42,830 --> 00:16:46,800
automatically also has the properties
that we listed before.

227
00:16:47,830 --> 00:16:53,940
So here you can see two examples of A and
B sets which are smaller and

228
00:16:53,940 --> 00:16:59,040
automatically satisfy all the requirements
as long as A and B are not empty.

229
00:17:00,470 --> 00:17:02,020
So that means that we

230
00:17:02,020 --> 00:17:07,150
would potentially get many,
many places and we don't want that.

231
00:17:07,150 --> 00:17:15,580
So we only retain the maximal
elements of this set X.

232
00:17:15,580 --> 00:17:18,510
And that is what we do in step five,

233
00:17:18,510 --> 00:17:22,980
yielding a set Y, which will
correspond to the internal places.

234
00:17:24,740 --> 00:17:32,100
And so, we delete all the elements
from X that are not maximumal.

235
00:17:32,100 --> 00:17:34,060
In the sense what I've just discussed.

236
00:17:35,450 --> 00:17:39,040
Now the remainder of the algorithm
is fairly simple.

237
00:17:39,040 --> 00:17:41,920
So PL is the set of places.

238
00:17:41,920 --> 00:17:48,090
So all the maximal pairs that we have just
discovered in step five are places and

239
00:17:48,090 --> 00:17:52,010
we add an initial place I and
a final place O.

240
00:17:54,240 --> 00:17:56,280
It's very easy to understand, yeah?

241
00:17:56,280 --> 00:18:01,150
So it's important to see that the really
interesting part happens when we

242
00:18:01,150 --> 00:18:05,620
look at these sets A and B, and thereby
derive the places that we want to see.

243
00:18:08,070 --> 00:18:11,760
Then we take a look at the arcs.

244
00:18:11,760 --> 00:18:14,560
And we already have the transitions,
we already have the places.

245
00:18:14,560 --> 00:18:16,210
Here you see the arcs.

246
00:18:16,210 --> 00:18:21,390
So here, you can see all
connections from the initial place,

247
00:18:21,390 --> 00:18:25,950
I, to all the initial transitions in TI.

248
00:18:25,950 --> 00:18:29,580
From all the transitions in the set TO.

249
00:18:29,580 --> 00:18:34,520
So the transitions corresponding to
the activities that happen at the end.

250
00:18:34,520 --> 00:18:41,110
And all internal places, and internal
places are represented by sets A and

251
00:18:41,110 --> 00:18:43,780
B and the connections
are made accordingly.

252
00:18:45,681 --> 00:18:48,750
So this is making the connections, but

253
00:18:48,750 --> 00:18:53,000
the real logic was already
in steps four and five.

254
00:18:53,000 --> 00:18:55,770
Where we identify the sets A and B.

255
00:18:57,830 --> 00:19:05,320
Finally, we return the Petri net with
places P, transitions D, and arcs F.

256
00:19:05,320 --> 00:19:08,430
And we get the result that we're after.

257
00:19:09,560 --> 00:19:13,540
So let's replay these eight lines.

258
00:19:13,540 --> 00:19:15,560
For example that we have seen before.

259
00:19:15,560 --> 00:19:17,400
So this is the log.

260
00:19:17,400 --> 00:19:19,300
This is the footprint matrix.

261
00:19:19,300 --> 00:19:21,710
So we can see all the relationships.

262
00:19:21,710 --> 00:19:25,370
Then we execute the different steps
of the algorithm where the key

263
00:19:25,370 --> 00:19:27,730
steps are steps four and steps five.

264
00:19:28,930 --> 00:19:31,770
So here you seek the relationship X.

265
00:19:32,880 --> 00:19:36,420
They contain elements
which are not maximal,

266
00:19:36,420 --> 00:19:39,490
some of these elements
are contained in other elements.

267
00:19:39,490 --> 00:19:43,720
So we remove them as is indicated here.

268
00:19:43,720 --> 00:19:50,970
Then we get a set Y, and
these correspond to the internal places.

269
00:19:50,970 --> 00:19:55,980
So, for example, we can see that
there will be a place having as

270
00:19:55,980 --> 00:19:59,330
input a and as output b and e.

271
00:20:00,750 --> 00:20:04,030
And that is what you can see in the,
in the corresponding diagram.

272
00:20:06,670 --> 00:20:12,020
So if we feed an event log to
a process mining tool like ProM,

273
00:20:12,020 --> 00:20:15,140
which is supporting the Alpha algorithm,
we can load the log.

274
00:20:15,140 --> 00:20:17,670
The log that I just used.

275
00:20:17,670 --> 00:20:24,560
And indeed ProM returns
the model that we just saw.

276
00:20:24,560 --> 00:20:29,570
So here you can see the Alpha algorithm
in action on a very tiny log.

277
00:20:31,390 --> 00:20:33,810
Let's take a look at some other examples.

278
00:20:33,810 --> 00:20:39,000
So, let's take a look at log
L3 that is shown here, and

279
00:20:39,000 --> 00:20:40,690
the first question would be.

280
00:20:40,690 --> 00:20:45,400
To apply the Alpha algorithm, what is
the footprint matrix of this event log?

281
00:20:46,970 --> 00:20:47,840
Try to draw it.

282
00:20:49,020 --> 00:20:52,160
If you do so, you will see this.

283
00:20:52,160 --> 00:20:56,150
This is the footprint matrix
that is resulting from it.

284
00:20:57,330 --> 00:20:57,830
So.

285
00:20:58,860 --> 00:21:02,110
For example if you look at the row a and

286
00:21:02,110 --> 00:21:07,330
column a we can see that a is
never followed by itself.

287
00:21:07,330 --> 00:21:10,370
Which is a clear thing that
one can see in the log.

288
00:21:10,370 --> 00:21:15,200
If you would look at row a and column b

289
00:21:15,200 --> 00:21:19,540
we see that a is sometimes followed
by b but never the other way around.

290
00:21:19,540 --> 00:21:22,209
Look at the log and
you can see that is indeed the case.

291
00:21:23,590 --> 00:21:27,040
And we can look at all the roles for
example if we look at c and

292
00:21:27,040 --> 00:21:30,860
d we will see that c is
sometimes followed by d and

293
00:21:30,860 --> 00:21:35,710
sometimes d is followed by c,
suggesting the concurrency relationship.

294
00:21:35,710 --> 00:21:38,360
So first we built a footprint matrix and

295
00:21:38,360 --> 00:21:43,590
then we apply the alpha
algorithm that we have seen before.

296
00:21:43,590 --> 00:21:48,330
So, given this footprint matrix,
we can execute the eight steps.

297
00:21:49,400 --> 00:21:52,270
So, please try to do this yourself.

298
00:21:52,270 --> 00:21:55,060
What is the model that
is resulting from this?

299
00:21:59,222 --> 00:22:02,252
If you apply all the different
steps then this is

300
00:22:02,252 --> 00:22:05,170
the process model that you discover.

301
00:22:05,170 --> 00:22:09,650
And so you need to check it yourself
that this is indeed the result that will

302
00:22:09,650 --> 00:22:10,180
be returned.

303
00:22:12,280 --> 00:22:15,240
So if we feed this log again to ProM,

304
00:22:15,240 --> 00:22:20,030
again we see exactly the model that
was predicted by the Alpha algorithm.

305
00:22:20,030 --> 00:22:25,100
Because ProM implements exactly the eight
line algorithm that we have seen before.

306
00:22:26,730 --> 00:22:29,100
Let's take a look at another event log.

307
00:22:29,100 --> 00:22:35,620
So now we see four different traces
happening at different frequencies.

308
00:22:35,620 --> 00:22:37,750
So if we take this event log

309
00:22:40,170 --> 00:22:45,470
we will discover this process
model using the Alpha algorithm.

310
00:22:45,470 --> 00:22:49,570
And take a look at the places and
the names that they have and

311
00:22:49,570 --> 00:22:53,200
identify these sets a and
b and you can see that this is

312
00:22:53,200 --> 00:22:56,250
actually the model that can
be derived based on this log.

313
00:22:56,250 --> 00:23:00,720
And also if you look at this
model we can reproduce all

314
00:23:00,720 --> 00:23:03,430
the traces that we see in the log and
nothing more.

315
00:23:05,470 --> 00:23:08,350
And ProM indeed returns the same model.

316
00:23:09,630 --> 00:23:11,180
Here we see another example.

317
00:23:11,180 --> 00:23:14,180
I'm trying to show you as
many examples as possible that you

318
00:23:14,180 --> 00:23:19,680
get a feeling for when this algorithm
indeed produces the right result.

319
00:23:19,680 --> 00:23:24,870
So if we take this event log you
can see the footprint matrix.

320
00:23:24,870 --> 00:23:27,390
We can apply the algorithm.

321
00:23:27,390 --> 00:23:30,990
So here you see all of
the eight steps listed.

322
00:23:32,060 --> 00:23:38,250
Where the steps to distinguish the X and
Y are the most crucial steps.

323
00:23:39,290 --> 00:23:42,670
Then we will get this Petri net.

324
00:23:42,670 --> 00:23:46,410
And again, we can see that this
is indeed a petri net that is

325
00:23:46,410 --> 00:23:49,330
able to reproduce the observed behavior.

326
00:23:49,330 --> 00:23:51,940
But also a bit more because the,

327
00:23:51,940 --> 00:23:54,590
the patterns in the log
suggest that there is a loop.

328
00:23:56,790 --> 00:24:01,790
So in summary, the Alpha algorithm
provides a basic discovery approach.

329
00:24:02,940 --> 00:24:04,160
It has many limitations.

330
00:24:04,160 --> 00:24:09,070
I didn't talk about these yet, I will
talk about them in the next lecture.

331
00:24:10,130 --> 00:24:14,530
But still the algorithm is very
useful because it illustrates the key

332
00:24:14,530 --> 00:24:16,590
ingredients of process discovery.

333
00:24:16,590 --> 00:24:21,050
Discovering loops, discovering
concurrency, discovering choices.

334
00:24:21,050 --> 00:24:21,700
It's all in there.

335
00:24:24,350 --> 00:24:28,280
So for understanding process discovery
it's very important that you

336
00:24:28,280 --> 00:24:33,190
practice with different examples,
apply the Alpha algorithm and

337
00:24:33,190 --> 00:24:37,540
you will gain a better understanding
of the difficulties that one

338
00:24:37,540 --> 00:24:42,139
encounters if one would like to discover
a process model just based on examples.

339
00:24:43,560 --> 00:24:46,020
So we now move to chapter five.

340
00:24:46,020 --> 00:24:49,200
And chapter five describes in
lots of detail with lots of

341
00:24:49,200 --> 00:24:52,810
examples what the Alpha
algorithm is actually doing.

342
00:24:54,620 --> 00:24:58,653
Thank you for watching and
I hope to see you in the next lecture.

343
00:24:58,653 --> 00:25:08,653
[MUSIC]

