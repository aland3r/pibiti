1
00:00:00,000 --> 00:00:07,408
[MUSIC]

2
00:00:07,408 --> 00:00:12,370
Welcome to this lecture of the course on
Process Mining: Data Science in Action.

3
00:00:12,370 --> 00:00:16,510
Today we will learn about
dependency graphs and causal nets.

4
00:00:16,510 --> 00:00:20,390
These are important because mining
algorithms like the Heuristic Miner

5
00:00:20,390 --> 00:00:21,330
are based on them.

6
00:00:23,360 --> 00:00:29,490
In earlier lectures, we have seen many
different types of process models.

7
00:00:29,490 --> 00:00:32,660
Sometimes we talk about a Tower
of Babel because there are so

8
00:00:32,660 --> 00:00:35,110
many process models to choose from.

9
00:00:35,110 --> 00:00:39,860
But the choice of process models
is very important during mining.

10
00:00:39,860 --> 00:00:44,730
This, we discussed elaborately when
we talked about representational bias

11
00:00:44,730 --> 00:00:46,600
of process mining.

12
00:00:46,600 --> 00:00:52,940
Today we will focus on two representations
which are used internally during mining.

13
00:00:53,970 --> 00:00:56,500
By algorithms like
the heuristic mining algorithm.

14
00:00:58,260 --> 00:01:03,430
So the first representation that we
will talk about are dependency graphs.

15
00:01:03,430 --> 00:01:06,940
So, dependency graphs
are very important to

16
00:01:06,940 --> 00:01:10,850
get the causal structure
of a process model.

17
00:01:10,850 --> 00:01:14,770
And, this is often used as input for
all kind of algorithms that look for

18
00:01:14,770 --> 00:01:16,220
more refined representations.

19
00:01:17,730 --> 00:01:19,990
Here you see an example
of a dependency graph.

20
00:01:21,180 --> 00:01:26,810
It is just a graph with arcs and nodes.
All the nodes correspond to activities.

21
00:01:27,930 --> 00:01:32,280
All the arcs correspond
to causal dependencies.

22
00:01:32,280 --> 00:01:36,640
And you can think of a causal dependency
as a relationship between two activities

23
00:01:36,640 --> 00:01:41,610
that is directed, where one is
triggering or enabling the other one.

24
00:01:44,120 --> 00:01:50,160
Arcs will be annotated with numbers,
these can represent frequencies,

25
00:01:50,160 --> 00:01:53,290
these can represent confidence,
how certain we

26
00:01:53,290 --> 00:01:58,150
are that there is a particular
causality between these two activities.

27
00:02:00,480 --> 00:02:05,400
So the challenge of building
such a dependency graph is that

28
00:02:05,400 --> 00:02:07,810
we need to deal with concurrency.

29
00:02:07,810 --> 00:02:11,300
So activities can be
interleafed in many ways, but

30
00:02:11,300 --> 00:02:14,440
that doesn't mean that they
causally depend on each other.

31
00:02:14,440 --> 00:02:17,290
So this is the challenge
that is very important.

32
00:02:19,290 --> 00:02:23,680
The graphs that we are looking at
now have no executable semantics.

33
00:02:23,680 --> 00:02:26,950
It's not like a petri net that,
based on such a model,

34
00:02:26,950 --> 00:02:33,150
there is a clear set of traces that is
possible according to a certain semantics.

35
00:02:35,190 --> 00:02:37,810
In other words,
if there are multiple ingoing and

36
00:02:37,810 --> 00:02:43,320
outgoing arcs, there is no clear AND
or XOR semantics.

37
00:02:43,320 --> 00:02:48,250
One can think of this as the input and
output behavior as a fuzzy fight

38
00:02:48,250 --> 00:02:53,210
version of the OR-join and OR-split
without having a very clear semantics.

39
00:02:53,210 --> 00:02:54,960
Sometimes you need one input.

40
00:02:54,960 --> 00:02:56,380
Sometimes you need two inputs.

41
00:02:57,610 --> 00:03:01,480
So we interpret them in a very loose way.

42
00:03:01,480 --> 00:03:05,630
Without associating any
executable semantics to it.

43
00:03:05,630 --> 00:03:09,710
So, let's relate this to some of the
representations that we have seen before.

44
00:03:09,710 --> 00:03:12,890
We all have seen diagrams like this.

45
00:03:12,890 --> 00:03:14,330
The causal footprint.

46
00:03:14,330 --> 00:03:20,930
The arrows in such a matrix correspond
to the arcs in the dependency graphs.

47
00:03:20,930 --> 00:03:22,940
So here you see the mapping.

48
00:03:22,940 --> 00:03:27,980
From such a footprint
to a dependency graph.

49
00:03:29,860 --> 00:03:32,790
We can also look at the Petri net,
so here you see a Petri net.

50
00:03:32,790 --> 00:03:36,910
And in essence,
if I would remove all the places, and

51
00:03:36,910 --> 00:03:42,290
just connect the activities directly as
they were connected through the places.

52
00:03:42,290 --> 00:03:48,180
But now after removing the places, then
we also get a kind of dependency graph.

53
00:03:48,180 --> 00:03:51,950
So a Petri net can be translated
into a dependency graph, but

54
00:03:51,950 --> 00:03:53,820
we lose lots of the semantics.

55
00:03:55,440 --> 00:03:56,620
Here's another example.

56
00:03:56,620 --> 00:03:59,270
Again, we take a look at the footprint.

57
00:03:59,270 --> 00:04:03,530
We look at the arrows that
are in the footprint matrix, and

58
00:04:03,530 --> 00:04:06,740
they correspond to the arrows
in the dependency graph.

59
00:04:08,320 --> 00:04:12,420
If we look at the corresponding Petri
net, again we can remove the places, and

60
00:04:12,420 --> 00:04:14,880
we get the corresponding dependency graph.

61
00:04:14,880 --> 00:04:19,520
So this gives an intuitive idea
of what the dependency graph is.

62
00:04:19,520 --> 00:04:24,280
It is something that has no semantics,
but that tries to capture causalities.

63
00:04:26,290 --> 00:04:28,030
Why are these important?

64
00:04:28,030 --> 00:04:31,710
These are important because all
kinds of mining algorithms,

65
00:04:33,130 --> 00:04:35,160
start from such a representation.

66
00:04:35,160 --> 00:04:40,100
They are using it in a first phase or
it is the final product that they show.

67
00:04:40,100 --> 00:04:45,480
So one can think of fuzzy models and
the models in disco as dependency graphs.

68
00:04:45,480 --> 00:04:49,030
So there's no precise semantics.

69
00:04:49,030 --> 00:04:52,050
There are many ways to create them.

70
00:04:52,050 --> 00:04:55,240
There are many algorithms to
create such dependency graphs.

71
00:04:56,330 --> 00:04:58,410
And they are often based on heuristics.

72
00:04:58,410 --> 00:05:03,360
So we will talk about later, we will talk
about the specific way of learning them,

73
00:05:03,360 --> 00:05:05,140
but there are many ways to do it actually.

74
00:05:07,260 --> 00:05:11,265
Dependency graphs have a fuzzy semantics.

75
00:05:11,265 --> 00:05:17,940
C-nets take these dependency graphs and
add a bit more semantics,

76
00:05:17,940 --> 00:05:22,699
but not by making them executable,
but more sketching the possibilities.

77
00:05:24,290 --> 00:05:28,640
So what you see here is an example
of a causal net.

78
00:05:28,640 --> 00:05:33,180
It's a dependency graph annotated
with so-called input and

79
00:05:33,180 --> 00:05:37,810
output bindings that are showing
what the possible behaviors are,

80
00:05:37,810 --> 00:05:41,760
without associating
an executable semantics to it.

81
00:05:43,790 --> 00:05:46,270
So why do we talk about C-nets?

82
00:05:46,270 --> 00:05:52,290
Well, many of the process mining
algorithms that can deal with noise and

83
00:05:52,290 --> 00:05:57,470
other advanced concepts, they use
a representation very similar to C-nets.

84
00:05:57,470 --> 00:06:00,710
And the primary example that we will
use here is the heuristics miner.

85
00:06:02,230 --> 00:06:05,450
It fits very well with
mainstream languages.

86
00:06:05,450 --> 00:06:12,890
They often talk about ors and ands in
a more elaborate way than what is possible

87
00:06:12,890 --> 00:06:18,050
in Petri net model or a transition
system, so there is a nice fit.

88
00:06:19,730 --> 00:06:24,421
Using C-nets we are able to mobile XOR's,
AND's, and

89
00:06:24,421 --> 00:06:29,893
very important OR's but
we do so without adding any other

90
00:06:29,893 --> 00:06:36,571
modeling elements like silent or
duplicate transitions in a Petri net.

91
00:06:36,571 --> 00:06:41,990
Last but not least,
we use C-net's to avoid non-signed models.

92
00:06:41,990 --> 00:06:47,130
So the semantics are in such a way that
we avoid having deadlocks in them.

93
00:06:49,160 --> 00:06:52,940
So the semantics are very loose,
as I explained before.

94
00:06:52,940 --> 00:06:55,000
The moment of choice is not fixed.

95
00:06:55,000 --> 00:06:57,120
We just look in hindsight.

96
00:06:57,120 --> 00:07:00,090
Does a trace fit into this model?

97
00:07:00,090 --> 00:07:02,810
Is there a possible explanation
according to this model?

98
00:07:04,330 --> 00:07:08,750
That whether trace behavior
fits with the model behavior.

99
00:07:10,610 --> 00:07:13,360
So if you look in the process mining book,

100
00:07:13,360 --> 00:07:17,130
you can see a formal description
of this type of notation.

101
00:07:17,130 --> 00:07:20,590
It's not important that you
are able to understand it now, but

102
00:07:20,590 --> 00:07:24,920
if you would like to read the details,
you can do so in chapter two.

103
00:07:24,920 --> 00:07:29,270
What is important is that there is one
initial activity that is a final activity,

104
00:07:29,270 --> 00:07:32,220
that there are these dependencies,
these connections between

105
00:07:32,220 --> 00:07:36,890
the different elements and
there are inputs and output bindings.

106
00:07:36,890 --> 00:07:40,580
So the definition of a binding can
be formalized, the definition of

107
00:07:40,580 --> 00:07:44,709
a state can be formalized and
based on these notions we can talk

108
00:07:45,710 --> 00:07:53,200
about sequences that are possible
according to such a C-net.

109
00:07:53,200 --> 00:07:56,860
But, as I said, I will try to
explain it in a more intuitive way.

110
00:07:56,860 --> 00:08:02,210
So there is one start activity,
in this case the start activity is a, and

111
00:08:02,210 --> 00:08:04,350
this will be the one that happened first.

112
00:08:04,350 --> 00:08:07,810
And a can only happen in
the first position of a trace.

113
00:08:07,810 --> 00:08:09,450
Not in any later positions.

114
00:08:10,490 --> 00:08:13,540
This a is a start activity and

115
00:08:13,540 --> 00:08:18,610
there are two output bindings so
after a there are two possibilities.

116
00:08:18,610 --> 00:08:23,400
We can either do b and
d or we can do c and d.

117
00:08:24,970 --> 00:08:25,710
Yeah?

118
00:08:25,710 --> 00:08:26,360
That's the idea.

119
00:08:27,360 --> 00:08:32,730
So after executing a, we need to
choose one of these output bindings,

120
00:08:32,730 --> 00:08:37,170
and here you can see that
the choice was made to do b and d.

121
00:08:38,400 --> 00:08:43,340
And if we take this binding it means that
we are creating the obligation that in

122
00:08:43,340 --> 00:08:48,090
the future b will need to happen and
d will need to happen.

123
00:08:48,090 --> 00:08:53,160
So, you're creating obligations and
the input bindings are able to

124
00:08:53,160 --> 00:08:57,130
remove these obligations, whereas
the output bindings are creating them.

125
00:08:58,600 --> 00:09:04,820
So, after b occurs we have removed
the obligation between a and b.

126
00:09:04,820 --> 00:09:08,240
And we have created
an obligation between b and e.

127
00:09:09,640 --> 00:09:14,200
So now, in the future,
we know that we will have to do e.

128
00:09:14,200 --> 00:09:17,520
And we will need to match it to
one of the input bindings of e.

129
00:09:17,520 --> 00:09:19,130
But e is not yet enabled.

130
00:09:20,160 --> 00:09:23,110
The next thing that will
happen is that d occurs.

131
00:09:23,110 --> 00:09:26,910
We remove an obligation
on the incoming side and

132
00:09:26,910 --> 00:09:29,200
we create an obligation
on the outgoing side.

133
00:09:31,160 --> 00:09:37,260
In the next step, we execute e and
we remove two obligations.

134
00:09:37,260 --> 00:09:42,570
So this is like an AND-join, but
not off all three incoming arcs,

135
00:09:42,570 --> 00:09:44,110
just from two of them.

136
00:09:44,110 --> 00:09:46,220
So you can think of this as an OR.

137
00:09:46,220 --> 00:09:50,820
We removed two obligations,
and we created a new one, and

138
00:09:50,820 --> 00:09:54,300
the new obligation says that g
will need to happen in the future.

139
00:09:55,670 --> 00:09:59,210
Then we execute g, we remove

140
00:09:59,210 --> 00:10:04,410
an obligation, we create an obligation
until we can do the final step.

141
00:10:04,410 --> 00:10:09,730
Where we execute the end activity,
which may only happen at the very end,

142
00:10:09,730 --> 00:10:12,920
where we again, remove an obligation.

143
00:10:12,920 --> 00:10:15,880
So this was one run of the model.

144
00:10:17,060 --> 00:10:19,320
So what are the rules of the game?

145
00:10:19,320 --> 00:10:23,330
We start always with the start activity,
and that can happen only once.

146
00:10:24,560 --> 00:10:28,560
At the end there is always
a designated end activity and

147
00:10:28,560 --> 00:10:32,346
the activities in between cannot
be the start and end activities.

148
00:10:32,346 --> 00:10:38,290
Obligations are like tokens and

149
00:10:38,290 --> 00:10:43,570
they need to be there in order to
be consumed by input bindings.

150
00:10:43,570 --> 00:10:46,460
And at the end there should
be no remaining obligations.

151
00:10:47,600 --> 00:10:49,950
At the moment of choice is not fixed.

152
00:10:49,950 --> 00:10:54,940
Only in hindsight we need to find
an explanation that has these

153
00:10:54,940 --> 00:10:56,400
properties that are listed here.

154
00:10:58,340 --> 00:11:00,010
So let's talk more about binding.

155
00:11:00,010 --> 00:11:03,430
So activity x in this diagram.

156
00:11:04,480 --> 00:11:09,810
Has two input bindings and
three output bindings and

157
00:11:09,810 --> 00:11:14,890
one possible execution of this
activity x is highlighted here in red.

158
00:11:14,890 --> 00:11:18,120
That we have an input
binding involving two,

159
00:11:19,490 --> 00:11:24,530
earlier activities and, so, there need
to be two, obligations from before.

160
00:11:24,530 --> 00:11:26,260
Before we can do x.

161
00:11:26,260 --> 00:11:29,070
And x is creating two
obligations into the future.

162
00:11:29,070 --> 00:11:32,920
And so
now you should look at this diagram.

163
00:11:32,920 --> 00:11:36,240
You should think of how
many bindings are there.

164
00:11:36,240 --> 00:11:40,040
How many bindings are possible
in this activity.

165
00:11:40,040 --> 00:11:43,650
That has two input bindings and
three output bindings.

166
00:11:46,590 --> 00:11:48,650
Well the answer is very simple.

167
00:11:48,650 --> 00:11:53,190
There are of course six possible bindings
because you can take any combination of

168
00:11:53,190 --> 00:11:56,800
an input binding with
any of the output bindings.

169
00:11:56,800 --> 00:11:58,670
So you get 2 times 3 and

170
00:11:58,670 --> 00:12:02,370
here in red all the six possible
combinations are highlighted.

171
00:12:04,580 --> 00:12:11,160
So, it is very important to see that we
only consider valid binding sequences.

172
00:12:11,160 --> 00:12:15,300
So we only look at executions
that go from beginning to end.

173
00:12:15,300 --> 00:12:19,530
Where each time you take an input binding
all the obligations are present and

174
00:12:19,530 --> 00:12:24,300
at the end all the obligations
have been consumed and

175
00:12:24,300 --> 00:12:25,940
there are no remaining obligations.

176
00:12:27,040 --> 00:12:31,680
Then we have a valid binding sequence,
and we only consider those.

177
00:12:32,860 --> 00:12:40,730
So, this way we avoid talking
about deadlocks and other things.

178
00:12:40,730 --> 00:12:43,450
We just talk about the behavior
of such a model in

179
00:12:43,450 --> 00:12:46,710
terms of it's valid binding sequences.

180
00:12:46,710 --> 00:12:48,960
So the moment of choice is not relevant.

181
00:12:48,960 --> 00:12:51,580
There is no executable semantics.

182
00:12:51,580 --> 00:12:55,480
It is just an explanation
of possible traces.

183
00:12:55,480 --> 00:13:00,830
So we talk about the fact that the
semantics are declarative in a way that

184
00:13:00,830 --> 00:13:06,010
they only describe possible
paths without telling when which

185
00:13:06,010 --> 00:13:07,590
decision was being made.

186
00:13:09,290 --> 00:13:13,940
Let's try to relate this to workflow
nets or Petri nets in general.

187
00:13:13,940 --> 00:13:15,570
If we take a C-net.

188
00:13:15,570 --> 00:13:16,710
A causal net.

189
00:13:16,710 --> 00:13:21,260
We can easily translate it into
a Petri net that allows for

190
00:13:21,260 --> 00:13:23,600
the behavior that we see in the C-net.

191
00:13:23,600 --> 00:13:27,360
And the translation 
is straightforward.

192
00:13:27,360 --> 00:13:30,460
We just take all the output bindings.

193
00:13:30,460 --> 00:13:33,320
And convert them into silent transitions.

194
00:13:33,320 --> 00:13:36,650
We take all the input bindings,
and create them.

195
00:13:36,650 --> 00:13:38,600
We create also silent transitions for
them.

196
00:13:39,760 --> 00:13:44,930
And then we connect where the arcs are,
we add places connecting

197
00:13:44,930 --> 00:13:50,670
the output bindings of one transition to
the input binding of another transition.

198
00:13:50,670 --> 00:13:54,220
That's the way that it works
and I think when you look at this picture.

199
00:13:54,220 --> 00:13:55,450
It is fairly straightforward.

200
00:13:56,540 --> 00:14:02,670
If you look at this workflow net, you will
see that there may be many bad behaviors,

201
00:14:02,670 --> 00:14:06,540
like deadlocks and
all kinds of other anomalies.

202
00:14:06,540 --> 00:14:09,130
But in terms of a C-net,
we do not talk about it.

203
00:14:09,130 --> 00:14:13,640
Because we only consider the valid
binding sequences to avoid.

204
00:14:13,640 --> 00:14:18,050
That our discovery techniques will
continuously generate models that we

205
00:14:18,050 --> 00:14:21,460
consider to be bad because
they have deadlocks.

206
00:14:21,460 --> 00:14:25,450
We have a more loose semantics
exploiting this behavior.

207
00:14:27,480 --> 00:14:31,450
So how do work flow nets and
C-nets relate to each other?

208
00:14:31,450 --> 00:14:38,450
Every valid binding sequence of the C-net
corresponds to a firing sequence

209
00:14:38,450 --> 00:14:43,600
of the workflow net that goes from
the initial marking to the final marking.

210
00:14:43,600 --> 00:14:46,330
We can call this a valid firing sequence.

211
00:14:47,640 --> 00:14:52,780
Every execution of the workflow net,
starting in the initial marking and

212
00:14:52,780 --> 00:14:57,610
ending in the final marking corresponds
to a valid binding sequence.

213
00:14:57,610 --> 00:15:00,960
But in the petri net,
in the workflow net there may

214
00:15:00,960 --> 00:15:06,200
be many executions that do not
correspond to a valid binding sequence,

215
00:15:06,200 --> 00:15:10,830
because they end up in a deadlock or
unable to reach the final state.

216
00:15:10,830 --> 00:15:15,349
So, when we talk about C-nets,
we only consider valid binding sequences.

217
00:15:16,360 --> 00:15:18,870
When we talk about workflow nets.

218
00:15:18,870 --> 00:15:23,700
We also are confronted with deadlocks and
livelocks that need to be considered.

219
00:15:25,220 --> 00:15:29,560
A workflow net does not need to be sound,
but this type of soundness is

220
00:15:29,560 --> 00:15:35,000
not required for C-nets because we
only use their declarative semantics.

221
00:15:35,000 --> 00:15:40,470
So, let's see whether you now understand
the declarative semantics of C-net.

222
00:15:40,470 --> 00:15:42,310
So here you see a C-net.

223
00:15:42,310 --> 00:15:48,010
So how many valid binding
sequences are there in this C-net?

224
00:15:48,010 --> 00:15:49,940
So take a minute to think about this.

225
00:15:53,780 --> 00:15:57,999
The answer is that there are 12
valid binding sequences.

226
00:15:59,090 --> 00:16:02,240
For example, we can decide to do just b.

227
00:16:02,240 --> 00:16:05,250
We can decide to do just c.

228
00:16:05,250 --> 00:16:10,990
We can decide to do b and d, but
then there are two possible combinations,

229
00:16:10,990 --> 00:16:15,280
because we can do first b and
then d, or in the other order.

230
00:16:15,280 --> 00:16:17,240
The same holds for c and d.

231
00:16:17,240 --> 00:16:21,990
We can also do these two but they can
do be done in two different orders and

232
00:16:21,990 --> 00:16:25,060
we have the possibility to do b, c, and

233
00:16:25,060 --> 00:16:29,360
d like all three of them they
can be done in any order so

234
00:16:29,360 --> 00:16:35,310
that again yields an extra six
possible binding sequences.

235
00:16:35,310 --> 00:16:37,214
So, that brings the total to 12.

236
00:16:39,140 --> 00:16:43,660
Here you see one of these
binding sequences highlighted.

237
00:16:43,660 --> 00:16:50,010
And so there is one binding sequence that,
creates the trace ADCE, and

238
00:16:50,010 --> 00:16:53,210
here you can see the bindings that
are involved highlighted in red.

239
00:16:54,840 --> 00:17:00,770
So the work flow interpretation
of a C-net, can be given

240
00:17:00,770 --> 00:17:06,890
by converting bindings into silent
transitions, indicated in black.

241
00:17:06,890 --> 00:17:10,370
That do not leave a trail
in the event logs,

242
00:17:10,370 --> 00:17:16,120
that have a behavior that is invisible but
that provide a very easy translation.

243
00:17:16,120 --> 00:17:19,970
But as said before the 

244
00:17:19,970 --> 00:17:22,480
corresponding workflow net
does not need to be sound.

245
00:17:24,210 --> 00:17:26,740
So we only consider valid sequences.

246
00:17:26,740 --> 00:17:33,120
Here you see the relationship
between the output bindings and

247
00:17:33,120 --> 00:17:35,480
the silent transitions modeling.

248
00:17:35,480 --> 00:17:37,890
All these possible combinations.

249
00:17:37,890 --> 00:17:41,720
Here if you look at the input
bindings of the end activity again we

250
00:17:41,720 --> 00:17:45,660
see that there are five silent transitions
corresponding to these bindings.

251
00:17:48,730 --> 00:17:51,598
The workflow-net may have deadlocks, but

252
00:17:51,598 --> 00:17:57,361
we don't consider them if we talked about
the semantics of the corresponding C-nets.

253
00:17:57,361 --> 00:18:01,990
C-nets are remarkably expressive just by

254
00:18:01,990 --> 00:18:05,010
the different interpretation
of their semantics.

255
00:18:05,010 --> 00:18:09,530
So here you see an example of
a C-net that has a behavior that

256
00:18:09,530 --> 00:18:13,210
cannot be expressed in
an ordinary petri net.

257
00:18:13,210 --> 00:18:14,730
Why is this the case?

258
00:18:14,730 --> 00:18:19,050
If you look carefully,
you will see that b, c,

259
00:18:19,050 --> 00:18:23,600
and d can happen an unbounded
number of times.

260
00:18:23,600 --> 00:18:26,420
So it can happen one million times.

261
00:18:26,420 --> 00:18:30,220
But it is ensured by the model
that they all will happen

262
00:18:31,890 --> 00:18:38,210
exactly the same number of times and
still the order is preserved.

263
00:18:38,210 --> 00:18:44,820
So you can not do first five
c's when you only did four b's.

264
00:18:44,820 --> 00:18:47,410
That's why these
causalities are preserved.

265
00:18:47,410 --> 00:18:50,060
And one can not express this in a
in a classical Petri net.

266
00:18:51,960 --> 00:18:53,150
So let's look at the question.

267
00:18:53,150 --> 00:19:01,570
If we look at this more complicated C-net,
you see here four binding sequences.

268
00:19:01,570 --> 00:19:06,647
Which of these four binding
sequences is not a valid one?

269
00:19:09,984 --> 00:19:16,730
The answer is that trace b does not
correspond to a valid binding sequence.

270
00:19:18,100 --> 00:19:19,740
And how can one see that?

271
00:19:19,740 --> 00:19:23,750
Well there are two reasons why
one can see that this 

272
00:19:23,750 --> 00:19:27,200
doesn't correspond
to a valid binding sequence.

273
00:19:27,200 --> 00:19:31,950
The second c is executed
before the second b,

274
00:19:31,950 --> 00:19:34,135
which is not possible
according to the C-net.

275
00:19:35,190 --> 00:19:39,780
Also, if we see the first d,
then it cannot be

276
00:19:39,780 --> 00:19:44,520
that after the first d there are still
b's, by the nature of the net.

277
00:19:44,520 --> 00:19:50,160
And these two properties are violated, so
this is not a, valid binding sequence.

278
00:19:51,970 --> 00:19:58,800
Many plug-ins in ProM use C-nets,
or some notation that is very similar

279
00:19:58,800 --> 00:20:02,690
to C-nets like heuristic nets and all
kinds of other terms that are being used.

280
00:20:02,690 --> 00:20:06,980
So here you see a C-net and
there are different visualizations here,

281
00:20:06,980 --> 00:20:10,980
we do not see the AND's and
the XOR's etcetera.

282
00:20:10,980 --> 00:20:14,510
One can make them graphical and so

283
00:20:14,510 --> 00:20:20,470
here you see a BPMN like
notation showing a C-net.

284
00:20:20,470 --> 00:20:22,240
But we can also take these nets and

285
00:20:22,240 --> 00:20:27,830
convert them to Petri nets and
now you can see the bindings all

286
00:20:27,830 --> 00:20:30,979
represented in terms of silent
transitions as I've shown before.

287
00:20:33,030 --> 00:20:37,890
So in the next two lectures we
will talk about heuristic mining,

288
00:20:37,890 --> 00:20:41,160
where we use C-nets and dependency graphs.

289
00:20:41,160 --> 00:20:45,260
So there will be one lecture devoted
to learning dependency graphs, and

290
00:20:45,260 --> 00:20:47,829
there will be one lecture
devoted to causal nets.

291
00:20:49,420 --> 00:20:52,210
If you would like to learn more,
in chapter two,

292
00:20:52,210 --> 00:20:55,540
we spoke about many different
types of process models.

293
00:20:55,540 --> 00:21:00,850
Now in chapter six, we are focusing
on more advanced mining techniques.

294
00:21:00,850 --> 00:21:05,762
And heuristic mining is one of these
more advanced techniques that we

295
00:21:05,762 --> 00:21:08,736
are discussing in the next two lectures.

296
00:21:08,736 --> 00:21:10,871
Thank you for watching this lecture.

297
00:21:10,871 --> 00:21:12,840
See you next time.

298
00:21:12,840 --> 00:21:21,187
[MUSIC]

